---
title: 排程
published: 2026-01-13
slug: "scheduling"
tags: [Self-Hosting]
category: Life
licenseName: "CC BY-NC-SA 4.0"
author: Windson
draft: false
cover: "https://img.windson.cc/images/2026/01/scheduling/cover.webp"
---


在寒假開始之前，期末地獄之中，就想說寒假有兩個月，一定要作點什麼。於是就列了一大串：

1. Pwn
2. CCNA
3. 離散數學
4. 組一台電腦
5. 玩[愛爾登法環](https://store.steampowered.com/app/1245620/ELDEN_RING/)
6. 原神要抽到[少女](https://act-webstatic.hoyoverse.com/puzzle/hk4e/pz_LwGS1oxt0J/resource/puzzle/2025/12/22/c5bbb925d7e1bf1919c3f69a3f591911_6907148233834562988.png?x-oss-process=image/format,webp/quality,Q_100)
7. 看 git、HTML、CSS
8. 追劇

隨便一列事情就多了好多，結果現在寒假過了一半，只學了一點點 Pwn 、看了很多劇還有組好電腦，其他的事情就被丟在 Ready queue 裡面，呈現一個快餓死的狀態。再這樣下去可能到開學我只會看越來越多的劇，所以要有一個方法來規劃我的時間，至少要讓每件事情都有點進展。

為了方便討論，先定義一下以下的用詞：  
- **等待時間**：從決定要做這件事情到實際開始做  
- **處理時間**：從決定要做這件事情到完成這件事  

## FCFS
**FCFS (First come, first served)**，先想到的先處理，或是先來的先處理，一次只能處理一件事，而且要做完了才能開始做一件事。根據每件事可能花費的時間不一樣，處理的順序會影響到平均完成時間。聽起來很繞口，所以舉個例子：

|事情|預計完成要花費的時間|
|---|---|
|$P_1$|24|
|$P_2$|3|
|$P_3$|3|

- **處理順序：$P_1 \rightarrow P_2 \rightarrow P_3$**  
    - 平均等待時間：$\frac{0+24+27}{3} = 17$  
    - 平均處理時間：$\frac{24+27+30}{3} = 27$  

這邊可以發現，如果把花費時間長的往後丟，那平均等待時間就會下降。所以改成：

- **處理順序：$P_2 \rightarrow P_3 \rightarrow P_1$**  
    - 平均等待時間：$\frac{0+3+6}{3} = 3$  
    - 平均處理時間：$\frac{3+6+30}{3} = 13$  

交換之後發現，等待時間縮短了。也就是說~~當有一堆人叫你做事的時候，他會少等一點~~。

## SJF
**SJF (Shortest Job First)**，花費時間最少的先做。基於上一個討論，發現到花費越短的先做會使得平均等待時間和平均處理時間下降。讓花費時間最短的先做，會有最短的平均等待時間（大家等你做完的平均時間會最短）。但是這件事情很不實際，在完成這件事情之前，我們不會知道準確會花多久的時間完成它，只能~~通靈~~預測。

***

剛剛的討論還少一個變數。在期末的時候，今天討論通識A的報告、明天要做選修課的報告還有~~前天社長丟給你的社團活動成果資料表還沒寫~~。事情不會在剛好一個時間點出現，有一個先後順序。所以要加一個定義：  
- **抵達時間**：你接到這個任務的時間點，他是時間點不是一段時間。

## Shortest remaining time first
**Shortest remaining time first**，剩餘時間最短的先做，是**SJF**的搶先版本（可以插隊）。舉個例子：
|事情|抵達時間|預計完成要花費的時間|
|---|---|---|
|$P_1$|0|8|
|$P_2$|1|4|
|$P_3$|2|9|
|$P_4$|3|5|

執行順序就會改成這樣，讓當前時間點上剩餘時間最短的先做：

![](https://img.windson.cc/images/2026/01/scheduling/srtf.webp)

- 平均等待時間：$\[(17-8-0)+(5-4-1)+(26-2-9)+(10-3-5)\] / 4 = 6.5$  
- 平均處理時間：$\[(17-0)+(5-1)+(26-2)+(10-3)\] / 4 = 13$  

***
以上的處理方法都會有一些問題。如果一直有時間花費很短的事情插進來，中斷掉花費比較長的工作，那花費時間比較久的工作就會永遠都輪不到他，就會餓死在 Ready queue 裡面，等待時間反而越來越長，到了死線都還沒做完。為了避免有事情作不完的情況，接下來要介紹 Round Robin。

## Round Robin
這個方法跟之前的比較沒有關係。首先訂出一個閾值，就是每次工作的時間段。如果這個任務在這個時間段之內沒有完成，它就必須回去排隊，我們則處理下一件事。等到再次排到他的時候，我們再繼續完成它。比如說今天要寫微積分、線性代數、普通物理，設定閾值是一小時。先寫微積分一小時，不管有沒有寫完都必須換線性代數；再寫線性代數一小時，不管有沒有寫完都必須換普通物理。等到三個小時過去，再回來寫微積分，依照這樣輪流直到全部完成。

這個方法的藝術在於要怎麼設定閾值。如果拉的太大，每件事都在一個區間內完成，會像在做 FCFS 一樣，就沒有設定閾值的必要。如果拉的太小，那就會一直在切換的路上。用3分鐘舉例，現在要算微積分。拿出平板打開微積分作業、找到要寫的那題（30秒），讀完題目（2分鐘），寫個30秒，恭喜要換線性代數了。這樣實際在寫的時間反而會很短，一直都在切換的路上。

***

如果以上都看懂的，恭喜你已經學會了一半的 *作業系統 -- CPU scheduling* 這個單元。這個想法已經在草稿堆裡堆了半個學期，當初在學這個單元的時候，想到其實 process 的執行 跟 人類處理事情 很像。只不過這件事情的 priority 不高，一直在 Waiting queue 裡面 starving。今天心血來潮~~好像很久沒發文~~才把他從草稿裡面拿出來完成。這輪 Round Robin 結束了，要是時候來去追劇了。




